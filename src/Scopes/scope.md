我们已经可以看到 AngularJS scope 中一些重要的性能特征:
* 在作用域上添加数据本身并不会有性能折扣。如果没有监听器在监控某个属性，它在不在作用域上都无所谓。
Angular并不会遍历作用域的属性，它遍历的是监听器。
* $digest里会调用每个监控函数，因此，最好关注监听器的数量，还有每个独立的监控函数或者表达式的性能。

由于每次都需要对watchFn求值，所以我们的watchFn要尽量简化。因为$watch中的watchFn至少执行两次，而listenerFn至少执行一次。

基于值的检查明显比基于引用的检查引入了更多的操作, 有时候更多. 遍历嵌套数据结构需要花费时间, 保存一个深 copy 需要消耗更多内存, 这也是为什么 Angular 默认不是基于值的检查.

在JavaScript里，NaN（Not-a-Number）并不等于自身.

## 总结一下几个常用方法：
使用不同的方式触发 digest 循环：
* 使用 $eval 和 $apply 立刻触发脏检查循环
* 使用 $evalAsync, $applyAsync 和 $$postDigest 使脏检查循环延迟执行
* 在方法中一定要注意捕获异常,不影响后续代码继续运行
* 使用 $watchGroup 监听多个表达式发生变化，触发同一个listenerFn，也就是多个引起因素，产生同一效果。